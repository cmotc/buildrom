[PATCH] mkelfImage: Take elf64 vmlinux and produce elf32

change to use e_entry instead of hardcode for vmlinux
if e_entry is not equal to paddr of fist phdr, will use paddr instead, and not switch to 64bit in convert
otherwise will use e_entry and switch to 64bit in convert

also fix the bss_size calculation.

Signed-off-By: Yinghai Lu <yinghai.lu@amd.com>

diff -uNr mkelfImage-2.7/linux-i386/convert.h mkelfImage-2.7.new/linux-i386/convert.h
--- mkelfImage-2.7/linux-i386/convert.h	2006-03-17 06:08:21.000000000 -0800
+++ mkelfImage-2.7.new/linux-i386/convert.h	2006-11-08 12:32:15.000000000 -0800
@@ -3,6 +3,8 @@
 #define CONVERTLOC 		0x10000
 #define REAL_MODE_DATA_LOC	0x20000
 #define GDTLOC	   		0x21000
+#define GDT64LOC		0x22000
+#define PGTLOC			0x23000
 
 #define DEFAULT_ROOT_DEV ((0x3<<8)| 0)
 
@@ -18,10 +20,13 @@
 struct image_parameters {
 	uint32_t convert_magic; /* a signature to verify mkelfImage was built properly */
 	uint32_t gdt_size;
+	uint32_t gdt64_size;
+	uint32_t pgt_size;
 	uint32_t bss_size;
 	uint16_t ramdisk_flags;
 	uint16_t root_dev;
 	uint32_t entry;
+	uint32_t switch_64;
 	uint32_t initrd_start;
 	uint32_t initrd_size;
 	uint8_t  cmdline[CMDLINE_MAX];
diff -uNr mkelfImage-2.7/linux-i386/convert.lds mkelfImage-2.7.new/linux-i386/convert.lds
--- mkelfImage-2.7/linux-i386/convert.lds	2003-01-16 13:41:14.000000000 -0800
+++ mkelfImage-2.7.new/linux-i386/convert.lds	2006-11-08 12:19:12.000000000 -0800
@@ -27,7 +27,7 @@
 		*(.bss)
 	}
 	_end = . ;
-	bss_size = _end - _bss;
+	bss_sizex = _end - _bss;
 	
 	/DISCARD/ : {
 		*(.comment)
diff -uNr mkelfImage-2.7/linux-i386/head.S mkelfImage-2.7.new/linux-i386/head.S
--- mkelfImage-2.7/linux-i386/head.S	2003-01-24 14:48:03.000000000 -0800
+++ mkelfImage-2.7.new/linux-i386/head.S	2006-11-08 12:19:32.000000000 -0800
@@ -59,7 +59,7 @@
 	movl	$GDTLOC, %edi
 	movl	$(gdt_end - gdt), %ecx
 	rep	movsb
-	
+
 	# Linux makes stupid assumptions about the segments
 	# that are already setup, so setup a new gdt & ldt
 	# and then reload the segment registers.
@@ -95,22 +95,113 @@
 	# Flag to indicate we are the bootstrap processor
 	xorl	%ebx, %ebx
 
+	movl    switch_64, %eax
+	cmp	$1, %eax
+	jz	switch_to_64
+
 	# Clear the unspecified registers for good measure
 	xorl	%eax, %eax
 	xorl	%ecx, %ecx
 	xorl	%edx, %edx
 	xorl	%edi, %edi
-	xorl	%esp, %esp
 	xorl	%ebp, %ebp
+
+	# do not clear esp, we still need to use lret later
+
+        pushl $PROT_CODE_SEG
+        movl entry, %eax
+        pushl %eax
+
+	lret
+
+switch_to_64:
+
+	/* We need to switch to 64bit before use startup_64 entry go to kernel */
+ /*
+  * Prepare for entering 64 bit mode
+  */
+        # Move the gdt64 where Linux will not smash it during decompression
+	movl	%esi, %eax # save the real mode pointer
+	movl    $gdt64, %esi
+	movl    $GDT64LOC, %edi
+	movl    $(gdt64_end - gdt64), %ecx
+	rep     movsb
+	movl	%eax, %esi
+
+	/* Load new GDT with the 64bit segments using 32bit descriptor */
+	lgdt	gdt64
+
+	/* Enable PAE mode */
+	xorl    %eax, %eax
+	btsl    $5, %eax
+	movl    %eax, %cr4
+
+ /*
+  * Build early 4G boot pagetable
+  */
+       /* Initialize Page tables to 0*/
+       movl    $PGTLOC, %edi
+       xorl    %eax, %eax
+       movl    $((4096*6)/4), %ecx
+       rep     stosl
+
+       /* Build Level 4 */
+       movl    $(PGTLOC + 0), %edi
+       leal    0x1007 (%edi), %eax
+       movl    %eax, 0(%edi)
+
+       /* Build Level 3 */
+       movl    $(PGTLOC + 0x1000), %edi
+       leal    0x1007(%edi), %eax
+       movl    $4, %ecx
+1:     movl    %eax, 0x00(%edi)
+       addl    $0x00001000, %eax
+       addl    $8, %edi
+       decl    %ecx
+       jnz     1b
+
+       /* Build Level 2 */
+       movl    $(PGTLOC + 0x2000), %edi
+       movl    $0x00000183, %eax
+       movl    $2048, %ecx
+1:     movl    %eax, 0(%edi)
+       addl    $0x00200000, %eax
+       addl    $8, %edi
+       decl    %ecx
+       jnz     1b
+
+       /* Enable the boot page tables */
+       movl    $PGTLOC, %eax
+       movl    %eax, %cr3
+
+       /* Enable Long mode in EFER (Extended Feature Enable Register) */
+       movl    $0xc0000080, %ecx
+       rdmsr
+       btsl    $8, %eax
+       wrmsr
+
+	/* Preparing for 64bit jmp */
+        pushl $PROT_CODE_SEG
+        movl entry, %eax
+        pushl %eax
+
+       /* Enter paged protected Mode, activating Long Mode */
+        xorl    %eax, %eax
+        btsl    $31, %eax
+        btsl    $0, %eax
+        movl    %eax, %cr0
+
+        /*
+         * At this point we're in long mode but in 32bit compatibility mode
+         * with EFER.LME = 1, CS.L = 0, CS.D = 1 (and in turn
+         * EFER.LMA = 1). Now we want to jump in 64bit mode, to do that we use
+         * the new gdt/idt that has __KERNEL_CS with CS.L = 1.
+         */
 
-
-	# Jump to the linux kernel
-	ljmp	$ PROT_CODE_SEG , $ 0x100000
+	lret
 
 
 	/* Routines to query the BIOS... */
-
-
 /**************************************************************************
 E820_MEMSIZE - Get a listing of memory regions
 **************************************************************************/
@@ -409,6 +500,7 @@
 	.word	0x9200				# data read/write
 	.word	0x00CF				# granularity = 4096, 386
 						#  (+5th nibble of limit)
+
 /*
  * The layout of the per-CPU GDT under Linux:
  *
@@ -446,7 +538,14 @@
  */
 gdt_end:
 
-
+gdt64:
+	.word	gdt64_end - gdt64
+	.long	GDT64LOC
+	.word	0
+	.quad	0x0000000000000000	/* NULL descriptor */
+	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
+	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
+gdt64_end:
 	
 	.section ".trailer", "a"
 	/* Constants set at build time, these are at the very end of my image */
@@ -458,14 +557,20 @@
 	.long	CONVERT_MAGIC
 gdt_size:
 	.long	gdt_end - gdt
+gdt64_size:
+	.long	gdt64_end - gdt64
+pgt_size:
+	.long   4096*6
 bss_size:
-	.long	bss_size
+	.long	bss_sizex
 ramdisk_flags:
 	.word	0
 root_dev:
 	.word	DEFAULT_ROOT_DEV
 entry:
 	.long	0
+switch_64:
+	.long	0
 initrd_start:
 	.long	0
 initrd_size:
diff -uNr mkelfImage-2.7/linux-i386/mkelf-linux-i386.c mkelfImage-2.7.new/linux-i386/mkelf-linux-i386.c
--- mkelfImage-2.7/linux-i386/mkelf-linux-i386.c	2006-03-17 06:08:22.000000000 -0800
+++ mkelfImage-2.7.new/linux-i386/mkelf-linux-i386.c	2006-11-08 09:54:58.000000000 -0800
@@ -19,13 +19,16 @@
 static void (*parse_kernel_type)(struct kernel_info *info, char *kernel_buf, size_t kernel_size);
 static void parse_bzImage_kernel(struct kernel_info *info, char *kernel_buf, size_t kernel_size);
 static void parse_elf32_kernel(struct kernel_info *info, char *kernel_buf, size_t kernel_size);
+static void parse_elf64_kernel(struct kernel_info *info, char *kernel_buf, size_t kernel_size);
+
+char *vmlinux_x86_64_probe(char *kernel_buf, off_t kernel_size);
 
 char *vmlinux_i386_probe(char *kernel_buf, off_t kernel_size)
 {
 	Elf32_Ehdr *ehdr;
 	Elf32_Phdr *phdr;
 	int i;
-	int hdr1, hdr2;
+	int phdrs;
 	ehdr = (Elf32_Ehdr *)kernel_buf;
 	if (
 		(ehdr->e_ident[EI_MAG0] != ELFMAG0) ||
@@ -35,7 +38,8 @@
 		return "No ELF signature found on kernel\n";
 	}
 	if (ehdr->e_ident[EI_CLASS] != ELFCLASS32) {
-		return "Not a 32bit ELF kernel\n";
+		return vmlinux_x86_64_probe(kernel_buf, kernel_size);
+//		return "Not a 32bit ELF kernel\n";
 	}
 	if (ehdr->e_ident[EI_DATA]  != ELFDATA2LSB) {
 		return "Not a little endian ELF kernel\n";
@@ -54,27 +58,64 @@
 		return "Kernel uses bad program header size.\n";
 	}
 	phdr = (Elf32_Phdr *)(kernel_buf + le32_to_cpu(ehdr->e_phoff));
-	hdr1 = hdr2 = -1;
-	for(i = 0; i < le32_to_cpu(ehdr->e_phnum); i++) {
+	phdrs = 0;
+	for(i = 0; i < le16_to_cpu(ehdr->e_phnum); i++) {
 		if (le32_to_cpu(phdr[i].p_type) != PT_LOAD)
 			continue;
-		if (((hdr1 != -1) && 
-			((le32_to_cpu(phdr[hdr1].p_paddr) & 0xfffffff) != 0x100000)) ||
-			(hdr2 != -1)) {
-			return "Too many PT_LOAD segments to be a linux kernel\n";
-		}
-		if (hdr1 == -1) {
-			hdr1 = i;
-		} else {
-			hdr2 = i;
-		}
+		phdrs++;
 	}
-	if (hdr1 == -1) {
+	if (phdrs == 0) {
 		return "No PT_LOAD segments!\n";
 	}
 	parse_kernel_type = parse_elf32_kernel;
 	return 0;
 }
+char *vmlinux_x86_64_probe(char *kernel_buf, off_t kernel_size)
+{
+        Elf64_Ehdr *ehdr;
+        Elf64_Phdr *phdr;
+        int i;
+	int phdrs = 0;
+        ehdr = (Elf64_Ehdr *)kernel_buf;
+        if (
+                (ehdr->e_ident[EI_MAG0] != ELFMAG0) ||
+                (ehdr->e_ident[EI_MAG1] != ELFMAG1) ||
+                (ehdr->e_ident[EI_MAG2] != ELFMAG2) ||
+                (ehdr->e_ident[EI_MAG3] != ELFMAG3)) {
+                return "No ELF signature found on kernel\n";
+        }
+        if (ehdr->e_ident[EI_CLASS] != ELFCLASS64) {
+                return "Not a 64bit ELF kernel\n";
+        }
+        if (ehdr->e_ident[EI_DATA]  != ELFDATA2LSB) {
+                return "Not a little endian ELF kernel\n";
+        }
+        if (le16_to_cpu(ehdr->e_type) != ET_EXEC) {
+                return "Not an executable kernel\n";
+        }
+        if (le16_to_cpu(ehdr->e_machine) != EM_X86_64) {
+                return "Not an x86_64 kernel\n";
+        }
+        if (    (ehdr->e_ident[EI_VERSION] != EV_CURRENT) ||
+                (le32_to_cpu(ehdr->e_version) != EV_CURRENT)) {
+                return "Kernel not using ELF version 1.\n";
+        }
+        if (le16_to_cpu(ehdr->e_phentsize) != sizeof(*phdr)) {
+                return "Kernel uses bad program header size.\n";
+        }
+        phdr = (Elf64_Phdr *)(kernel_buf + le64_to_cpu(ehdr->e_phoff));
+	phdrs = 0;
+        for(i = 0; i < le16_to_cpu(ehdr->e_phnum); i++) {
+                if (le32_to_cpu(phdr[i].p_type) != PT_LOAD)
+                        continue;
+		phdrs++;
+        }
+        if (phdrs == 0) {
+                return "No PT_LOAD segments!\n";
+        }
+        parse_kernel_type = parse_elf64_kernel;
+        return 0;
+}
 
 char *bzImage_i386_probe(char *kernel_buf, off_t kernel_size)
 {
@@ -118,17 +159,14 @@
 
 struct kernel_info
 {
-	void *kernel;
-	size_t filesz;
-	size_t memsz;
-	size_t paddr;
-	size_t vaddr;
-	void *kernel2;
-	size_t filesz2;
-	size_t memsz2;
-	size_t paddr2;
-	size_t vaddr2;
+	int phdrs;
+	void *kernel[4];
+	size_t filesz[4];
+	size_t memsz[4];
+	size_t paddr[4];
+	size_t vaddr[4];
 	size_t entry;
+	size_t switch_64;
 	char *version;
 };
 
@@ -137,43 +175,68 @@
 	Elf32_Ehdr *ehdr;
 	Elf32_Phdr *phdr;
 	int i;
-	int hdr1, hdr2;
+	int phdrs;
 	ehdr = (Elf32_Ehdr *)kernel_buf;
 	phdr = (Elf32_Phdr *)(kernel_buf + ehdr->e_phoff);
-	hdr1 = hdr2 = -1;
+	phdrs = 0;
 	for(i = 0; i < le16_to_cpu(ehdr->e_phnum); i++) {
 		if (le32_to_cpu(phdr[i].p_type) != PT_LOAD)
 			continue;
-		if (hdr2 != -1) {
-			die("Too many PT_LOAD segments to be a linux kernel\n");
-		}
-		if (hdr1 == -1) {
-			hdr1 = i;
-		} else {
-			hdr2 = i;
-		}
-	}
-	if (hdr1 == -1) {
-		die("No PT_LOAD segments!\n");
+		info->kernel[phdrs]  = kernel_buf + le32_to_cpu(phdr[i].p_offset);
+		info->filesz[phdrs]  = le32_to_cpu(phdr[i].p_filesz);
+		info->memsz[phdrs]   = le32_to_cpu(phdr[i].p_memsz);
+		info->paddr[phdrs]   = le32_to_cpu(phdr[i].p_paddr) & 0xfffffff;
+		info->vaddr[phdrs]   = le32_to_cpu(phdr[i].p_vaddr);
+		phdrs++;
 	}
-	info->kernel  = kernel_buf + le32_to_cpu(phdr[hdr1].p_offset);
-	info->filesz  = le32_to_cpu(phdr[hdr1].p_filesz);
-	info->memsz   = le32_to_cpu(phdr[hdr1].p_memsz);
-	info->paddr   = le32_to_cpu(phdr[hdr1].p_paddr) & 0xfffffff;
-	info->vaddr   = le32_to_cpu(phdr[hdr1].p_vaddr);
-
-	if (hdr2 != -1) {
-		info->kernel2 = kernel_buf + le32_to_cpu(phdr[hdr2].p_offset);
-		info->filesz2 = le32_to_cpu(phdr[hdr2].p_filesz);
-		info->memsz2  = le32_to_cpu(phdr[hdr2].p_memsz);
-		info->paddr2  = le32_to_cpu(phdr[hdr2].p_paddr) & 0xfffffff;
-		info->vaddr2  = le32_to_cpu(phdr[hdr2].p_vaddr);
+
+	if(!phdrs)
+		die("We need at least one phdr\n");
+
+	info->phdrs = phdrs;
+        info->entry   = le32_to_cpu(ehdr->e_entry);
+	info->switch_64   = 0; //not convert from elf64
+	info->version = "unknown";
+}
+
+static void parse_elf64_kernel(struct kernel_info *info, char *kernel_buf, size_t kernel_size)
+{
+        Elf64_Ehdr *ehdr;
+        Elf64_Phdr *phdr;
+        int i;
+	int phdrs;
+        ehdr = (Elf64_Ehdr *)kernel_buf;
+        phdr = (Elf64_Phdr *)(kernel_buf + le64_to_cpu(ehdr->e_phoff));
+
+	phdrs = 0;
+	for(i = 0; i < le16_to_cpu(ehdr->e_phnum); i++) {
+		if (le32_to_cpu(phdr[i].p_type) != PT_LOAD)
+			continue;
+		info->kernel[phdrs]  = kernel_buf + le64_to_cpu(phdr[i].p_offset);
+		info->filesz[phdrs]  = le64_to_cpu(phdr[i].p_filesz);
+		info->memsz[phdrs]   = le64_to_cpu(phdr[i].p_memsz);
+		info->paddr[phdrs]   = le64_to_cpu(phdr[i].p_paddr) & 0xffffff;
+		info->vaddr[phdrs]   = le64_to_cpu(phdr[i].p_vaddr);
+		phdrs++;
 	}
+
+	if(!phdrs)
+		die("We need at least one phdr\n");
 	
-	info->entry   = 0x100000;
-	info->version = "unknown";
+	info->phdrs = phdrs;
+        info->entry   = le64_to_cpu(ehdr->e_entry);
+#if  0
+	if (info->entry != info->paddr[0]) {
+		info->entry = info->paddr[0]; // we still have startup_32 there
+		info->switch_64   = 0; //not convert from elf64
+	} else
+#endif
+		info->switch_64   = 1; //convert from elf64
+
+        info->version = "unknown";
 }
 
+
 static void parse_bzImage_kernel(struct kernel_info *info, char *kernel_buf, size_t kernel_size)
 {
 	struct x86_linux_header *hdr;
@@ -186,12 +249,14 @@
 	}
 	offset = 512 + (512 *setup_sects);
 
-	info->kernel  = kernel_buf + offset;
-	info->filesz  = kernel_size - offset;
-	info->memsz   = 0x700000;
-	info->paddr   = 0x100000;
-	info->vaddr   = 0x100000;
-	info->entry   = info->paddr;
+	info->kernel[0]  = kernel_buf + offset;
+	info->filesz[0]  = kernel_size - offset;
+	info->memsz[0]   = 0x700000;
+	info->paddr[0]   = 0x100000;
+	info->vaddr[0]   = 0x100000;
+	info->phdrs = 1;
+	info->entry   = info->paddr[0];
+	info->switch_64   = 0; //not convert from elf64, even later bzImage become elf64, it still includes startup_32
 	info->version = kernel_buf + 512 + le16_to_cpu(hdr->kver_addr);
 }
 
@@ -237,6 +302,7 @@
 	struct kernel_info kinfo;
 	struct image_parameters *params;
 	int index;
+	int i;
 
 	int opt;
 	static const struct option options[] = {
@@ -310,7 +376,7 @@
 	
 	/* Add a program header for the note section */
 	index = 4;
-	index += kinfo.kernel2 ? 1:0;
+	index += (kinfo.phdrs - 1);
 	index += ramdisk_size ? 1:0;
 	phdr = add_program_headers(ehdr, index);
 
@@ -328,23 +394,24 @@
 	phdr[2].p_paddr  = REAL_MODE_DATA_LOC;
 	phdr[2].p_vaddr  = REAL_MODE_DATA_LOC;
 	phdr[2].p_filesz = 0;
-	phdr[2].p_memsz  = (GDTLOC - REAL_MODE_DATA_LOC) + params->gdt_size;
+	if(!kinfo.switch_64)
+		phdr[2].p_memsz = (GDTLOC - REAL_MODE_DATA_LOC) + params->gdt_size;
+	else
+		phdr[2].p_memsz = (PGTLOC - REAL_MODE_DATA_LOC) + params->pgt_size;
 	phdr[2].p_data   = 0;
 
-	phdr[3].p_paddr  = kinfo.paddr;
-	phdr[3].p_vaddr  = kinfo.vaddr;
-	phdr[3].p_filesz = kinfo.filesz;
-	phdr[3].p_memsz  = kinfo.memsz;
-	phdr[3].p_data   = kinfo.kernel;
+	if( (phdr[1].p_paddr + phdr[1].p_memsz) > phdr[2].p_paddr) {
+		die("Internal error: need to increase REAL_MODE_DATA_LOC !\n");
+	}
 
-	index = 4;
+	index = 3;
 	/* Put the second kernel frament if present */
-	if (kinfo.kernel2) {
-		phdr[index].p_paddr  = kinfo.paddr2;
-		phdr[index].p_vaddr  = kinfo.vaddr2;
-		phdr[index].p_filesz = kinfo.filesz2;
-		phdr[index].p_memsz  = kinfo.memsz2;
-		phdr[index].p_data   = kinfo.kernel2;
+	for(i=0;i<kinfo.phdrs;i++) {
+		phdr[index].p_paddr  = kinfo.paddr[i];
+		phdr[index].p_vaddr  = kinfo.vaddr[i];
+		phdr[index].p_filesz = kinfo.filesz[i];
+		phdr[index].p_memsz  = kinfo.memsz[i];
+		phdr[index].p_data   = kinfo.kernel[i];
 		index++;
 	}
 	
@@ -352,6 +419,10 @@
 	 */
 	params->initrd_start = params->initrd_size = 0;
 	if (ramdisk_size) {
+		if( (phdr[index-1].p_paddr + phdr[index-1].p_memsz) > ramdisk_base) {
+			die("need to increase increase ramdisk_base !\n");
+		}
+
 		phdr[index].p_paddr  = ramdisk_base;
 		phdr[index].p_vaddr  = ramdisk_base;
 		phdr[index].p_filesz = ramdisk_size;
@@ -364,6 +435,7 @@
 	
 	/* Set the start location */
 	params->entry = kinfo.entry;
+	params->switch_64 = kinfo.switch_64;
 	ehdr->e_entry = phdr[1].p_paddr;
 
 	/* Setup the elf notes */
diff -uNr mkelfImage-2.7/linux-ia64/mkelf-linux-ia64.c mkelfImage-2.7.new/linux-ia64/mkelf-linux-ia64.c
--- mkelfImage-2.7/linux-ia64/mkelf-linux-ia64.c	2006-03-17 10:09:16.000000000 -0800
+++ mkelfImage-2.7.new/linux-ia64/mkelf-linux-ia64.c	2006-11-07 18:14:27.000000000 -0800
@@ -81,7 +81,7 @@
 	phdr = (Elf64_Phdr *)(kernel_buf + le64_to_cpu(ehdr->e_phoff));
 	phdrs = 0;
 	for(i = 0; i < le16_to_cpu(ehdr->e_phnum); i++) {
-		if (le16_to_cpu(phdr[i].p_type) != PT_LOAD)
+		if (le32_to_cpu(phdr[i].p_type) != PT_LOAD)
 			continue;
 		phdrs++;
 	}
